-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Bubble Gum Simulator Bot ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

if not game:IsLoaded() then
    game.Loaded:wait()
end

task.wait(10)

spawn(function()
    local success, result = pcall(function()
        task.wait(60)
        
        if workspace:FindFirstChild("Rendered") and workspace.Rendered:FindFirstChild("Generic") then
            if workspace.Rendered.Generic:FindFirstChild("100M Egg") then
                return true
            else
                for i, v in pairs(workspace.Rendered.Generic:GetChildren()) do
                    if v.Name == "100M Egg" then
                        return true
                    end
                end
            end
        end
        
        game:GetService("Players").LocalPlayer:Kick("100M Egg not available in this server. Please rejoin a different server.")
        return false
    end)
    
    if not success then
        print("Error checking for 100M Egg: " .. tostring(result))
    end
end)

spawn(function()
    task.wait(30)

    local vu = game:GetService("VirtualUser")
    game:GetService("Players").LocalPlayer.Idled:connect(function()
        vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
        wait(1)
        vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
    end)
end)

spawn(function()
    task.wait(30)
    
    local HatchEggModule = nil

    for _, func in next, getgc(true) do
        if typeof(func) == "function" and getfenv(func).script then
            local scriptName = getfenv(func).script.Name
            local scriptParent = getfenv(func).script.Parent

            if scriptName == "HatchEgg" and tostring(scriptParent) == "Effects" then
                local env = getfenv(func)
                local module = require(env.script)

                if typeof(module) == "table" then
                    HatchEggModule = module
                    break
                end
            end
        end
    end

    if HatchEggModule then
        for key, value in pairs(HatchEggModule) do
            if typeof(value) == "function" then
                HatchEggModule[key] = function(...) return end
            end
        end
        print("✅ Hatch animation functions disabled.")
    else
        warn("❌ Failed to find HatchEgg module.")
    end
end)

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Local Stuff ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local GuiService            = game:GetService("GuiService")
local VIM                   = game:GetService("VirtualInputManager")
local TweenService          = game:GetService("TweenService")
local Players               = game:GetService("Players")
local HttpService           = game:GetService("HttpService")
local Remote                = game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote
local LocalDataService      = require(game:GetService("ReplicatedStorage").Client.Framework.Services.LocalData)
local data                  = LocalDataService:Get()

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Trade Secret Pets ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoTradeSecretPets_Toggle = false
local tradeThread = nil
local targetTradeName = "YOUR_USERNAME" -- Put your username to auto trade secret pets to your account

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Bubble & Sell Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local Auto_Bubble_And_Sell_Active = false
local Auto_Bubble_And_Sell_Thread = nil

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Use Potion Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoUsingPotions = false
local autoUsingPotionsThread = nil
local isHatchingX25Egg = false

local priorityPotions = {
    "Lucky",
    "Speed",
    "Mythic"
}

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Collect Pickup Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoCollectingPickups = false
local autoCollectingPickupsThread = nil

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Hatch Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoHatching = false
local autoHatchingThread = nil
local tempDisableHatching = false
local pickupCollectionStartedByHatcher = false

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━ Coin & Gems Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local Max_Coins =   400000000000
local Low_Coins =   100000000

local Max_Gems  =   100000000
local Low_Gems  =   10000000

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Enchant Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local enchants = {
    ["team-up"] = 5
}

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Area To Unlock ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AreaToUnlock = {
    "Floating Island",
    "Outer Space",
    "Twilight",
    "The Void",
    "Zen"
}

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Mastery ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoMastery = false
local autoMasteryThread = nil

local PetsMasteryCompleted = false
local BuffsMasteryCompleted = false
local ShopsMasteryCompleted = false
local AllMasteryCompleted = false

local Target_Pets_Mastery = 15
local Target_Buffs_Mastery = 17
local Target_Shops_Mastery = 10

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Egg Counter ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local EggCounterGui = nil
local isEggCounterEnabled = false
local CurrentlyHatchingEgg = nil

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Secret Pet Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local SecretPets = {
    "Avernus",
    "King Doggy",
    "The Overlord",
    "MAN FACE GOD",
    "Royal Trophy",
    "Giant Chocolate Chicken",
    "Easter Basket",
    "Dementor",
    "Godly Gem"
}

local SecretPetCheck_Toggle = false
local SecretPetOverlay = nil

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Egg List & Priority ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local Default_Egg = CFrame.new(19, 2, -2)

local eggMapping = {
    ["common-egg"] = "Common Egg",
    ["void-egg"] = "Void Egg",
    ["silly-egg"] = "Silly Egg",
    ["100M Egg"] = "100M Egg"

}

local eggPriority = {
    "silly-egg",
    "void-egg",
    "common-egg",
    "100M Egg"
}

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Craft Potion Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local potionTypes = {
    "Lucky",
    "Speed",
    "Mythic",
    "Coins"
}

local craftingRequirements = {
    [2] = 4,
    [3] = 4,
    [4] = 6,
    [5] = 8
}


-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Pet List To Delete ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local petKeepThreshold = 1
local shinyKeepThreshold = 5

local petsToDelete = {
    "Doggy",
    "Kitty",
    "Bunny",
    "Bear",
    "Mouse",
    "Wolf",
    "Fox",
    "Polar Bear",
    "Panda",
    "Ice Kitty",
    "Deer",
    "Ice Wolf",
    "Piggy",
    "Ice Deer",
    "Ice Dragon",
    "Golem",
    "Dinosaur",
    "Ruby Golem",
    "Dragon",
    "Dark Dragon",
    "Emerald Golem",
    "Magma Doggy",
    "Magma Deer",
    "Magma Fox",
    "Magma Bear",
    "Demon",
    "Inferno Dragon",
    "Cave Bat",
    "Dark Bat",
    "Angel",
    "Emerald Bat",
    "Unicorn",
    "Flying Pig",
    "Space Mouse",
    "Space Bull",
    "Lunar Fox",
    "Lunarcorn",
    "Lunar Serpent",
    "Electra",
    "Void Kitty",
    "Void Bat",
    "Void Demon",
    "Dark Phoenix",
    "Neon Elemental",
    "Hell Piggy",
    "Hell Dragon",
    "Hell Crawler",
    "Inferno Demon",
    "Inferno Cube",
    "Virus",
    "Demon Doggy",
    "Skeletal Deer",
    "Night Crawler",
    "Hell Bat",
    "Green Hydra",
    "Demonic Hydra",
    "Red Golem",
    "Orange Deer",
    "Yellow Fox",
    "Green Angel",
    "Manny",
    "Manicorn",
    "Sigma Serpent",
    "Manarium",
    "Paper Doggy",
    "Paper Bunny",
    "Chubby Bunny",
    "Hatchling",
    "Bunny Doggy",
    "Egg Bunny",
    "Angel Bunny",
    "Seraphic Bunny",
    "Bow Bunny",
    "Easter Egg",
    "Flying Bunny",
    "Easter Serpent",
    "Bronze Bunny",
    "Silver Fox",
    "Golden Dragon",
    "Diamond Serpent",
    "Diamond Hexarium",
    "King Pufferfish"
}

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Flavors & Gum Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoBuy_Toggle = false
local Buy_Thread = nil
local max_Flavor_Reached = false
local max_Gum_Reached = false
local max_Upgrades_Reached = false

local flavorsConfig = {
    ["Blueberry"] = {
        price = 25,
        currency = "Coins"
    },
    ["Cherry"] = {
        price = 500,
        currency = "Coins"
    },
    ["Pizza"] = {
        price = 1500,
        currency = "Coins"
    },
    ["Watermelon"] = {
        price = 3500,
        currency = "Coins"
    },
    ["Chocolate"] = {
        price = 10000,
        currency = "Coins"
    },
    ["Contrast"] = {
        price = 35000,
        currency = "Coins"
    },
    ["Gold"] = {
        price = 100000,
        currency = "Coins"
    },
    ["Lemon"] = {
        price = 450000,
        currency = "Coins"
    },
    ["Donut"] = {
        price = 1500000,
        currency = "Coins"
    },
    ["Swirl"] = {
        price = 30000000,
        currency = "Coins"
    },
    ["Molten"] = {
        price = 350000000,
        currency = "Coins"
    }
}

local gumConfig = {
    ["Stretchy Gum"] = {
        price = 25,
        currency = "Coins"
    },
    ["Chewy Gum"] = {
        price = 250,
        currency = "Coins"
    },
    ["Epic Gum"] = {
        price = 1500,
        currency = "Coins"
    },
    ["Ultra Gum"] = {
        price = 5000,
        currency = "Coins"
    },
    ["Omega Gum"] = {
        price = 12000,
        currency = "Coins"
    },
    ["Unreal Gum"] = {
        price = 45000,
        currency = "Coins"
    },
    ["Cosmic Gum"] = {
        price = 125000,
        currency = "Coins"
    },
    ["XL Gum"] = {
        price = 650000,
        currency = "Coins"
    },
    ["Mega Gum"] = {
        price = 1500000,
        currency = "Coins"
    },
    ["Quantum Gum"] = {
        price = 5000000000,
        currency = "Coins"
    },
    ["Alien Gum"] = {
        price = 35000000,
        currency = "Coins"
    },
    ["Radioactive Gum"] = {
        price = 150000000,
        currency = "Coins"
    },
    ["Experiment #52"] = {
        price = 1000000000,
        currency = "Coins"
    }
}

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Helper ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function GetCurrentCoins()
    return LocalDataService:Get().Coins
end

local function GetCurrentGems()
    return LocalDataService:Get().Gems
end

local function getPetById(data, id)
    for _, pet in ipairs(data.Pets) do
        if pet.Id == id then
            return pet
        end
    end
end

local function FormatNumberCompact(num)
    if num >= 1e18 then return string.format("%.1fQnt", num / 1e18)
    elseif num >= 1e15 then return string.format("%.1fQ", num / 1e15)
    elseif num >= 1e12 then return string.format("%.1fT", num / 1e12)
    elseif num >= 1e9 then return string.format("%.1fB", num / 1e9)
    elseif num >= 1e6 then return string.format("%.1fM", num / 1e6)
    elseif num >= 1e3 then return string.format("%.1fK", num / 1e3)
    else return tostring(num)
    end
end

local function extractNumbers(text)
    local cleanText = text:gsub("<[^>]+>", "")
    
    local currentStr, maxStr = cleanText:match("([%d%,%.]+)%s*/%s*([%d%,%.]+)")
    
    if not currentStr or not maxStr then
        return nil, nil
    end
    
    currentStr = currentStr:gsub(",", "")
    maxStr = maxStr:gsub(",", "")
    
    return tonumber(currentStr), tonumber(maxStr)
end

local function convertPriceToNumber(priceText)
    local cleanPrice = priceText:gsub(",", ""):gsub("%s+", "")
    
    local value = tonumber(cleanPrice:match("^%d+%.?%d*"))
    if not value then return 999999999999 end
    
    if cleanPrice:match("[Kk]$") then
        value = value * 1000
    elseif cleanPrice:match("[Mm]$") then
        value = value * 1000000
    elseif cleanPrice:match("[Bb]$") then
        value = value * 1000000000
    end
    
    return value
end
-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Function Tween ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

function TweenCharacterToTarget(targetPart)
    if not targetPart then
        warn("Target part not provided!")
        return
    end
    
    local horizontalSpeed = 16
    local verticalSpeed = math.huge
    
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local startCFrame = humanoidRootPart.CFrame
    local targetPosition = targetPart.Position + Vector3.new(1, 5, 1)
    
    local downwardPosition = startCFrame.Position + Vector3.new(0, -20, 0)
    local downwardCFrame = CFrame.new(downwardPosition) * (startCFrame - startCFrame.Position)
    
    local intermediatePosition = Vector3.new(targetPosition.X, downwardPosition.Y, targetPosition.Z)
    local intermediateCFrame = CFrame.new(intermediatePosition) * (startCFrame - startCFrame.Position)
    
    local finalCFrame = CFrame.new(targetPosition) * (startCFrame - startCFrame.Position)
    
    local downwardDistance = math.abs(startCFrame.Position.Y - downwardPosition.Y)
    local horizontalDistance = (Vector3.new(downwardPosition.X, 0, downwardPosition.Z) - Vector3.new(intermediatePosition.X, 0, intermediatePosition.Z)).Magnitude
    local verticalDistance = math.abs(intermediatePosition.Y - targetPosition.Y)
    
    local downwardTime = downwardDistance / verticalSpeed
    local horizontalTime = horizontalDistance / horizontalSpeed
    local verticalTime = verticalDistance / verticalSpeed
    
    local tweenInfoDownward = TweenInfo.new(downwardTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tweenInfoHorizontal = TweenInfo.new(horizontalTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tweenInfoVertical = TweenInfo.new(verticalTime, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    
    local downwardTween = TweenService:Create(humanoidRootPart, tweenInfoDownward, { CFrame = downwardCFrame })
    local horizontalTween = TweenService:Create(humanoidRootPart, tweenInfoHorizontal, { CFrame = intermediateCFrame })
    local verticalTween = TweenService:Create(humanoidRootPart, tweenInfoVertical, { CFrame = finalCFrame })
    
    downwardTween.Completed:Connect(function(playbackState)
        if playbackState == Enum.PlaybackState.Completed then
            horizontalTween:Play()
        end
    end)
    
    horizontalTween.Completed:Connect(function(playbackState)
        if playbackState == Enum.PlaybackState.Completed then
            verticalTween:Play()
        end
    end)
    
    downwardTween:Play()
    
    return horizontalTween, verticalTween, downwardTween
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Trade Secret Pets ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoTradeSecretPets_Toggle = false
local tradeThread = nil
local targetTradeName = "PixyPalx"

local function autoTradeSecretPets()
    AutoTradeSecretPets_Toggle = not AutoTradeSecretPets_Toggle
    
    if AutoTradeSecretPets_Toggle then
        tradeThread = spawn(function()
            while AutoTradeSecretPets_Toggle do
                local targetPlayer = game:GetService("Players"):FindFirstChild(targetTradeName)
                
                if not targetPlayer then
                    for i = 1, 300 do
                        if not AutoTradeSecretPets_Toggle then break end
                        if game:GetService("Players"):FindFirstChild(targetTradeName) then break end
                        task.wait(1)
                    end
                    task.wait(1)
                    continue
                end
                
                local freshPetData = LocalDataService:Get()
                local hasSecretPets = false
                
                if freshPetData and freshPetData.Pets then
                    for _, pet in pairs(freshPetData.Pets) do
                        for _, secretPetName in pairs(SecretPets) do
                            if pet.Name == secretPetName then
                                hasSecretPets = true
                                break
                            end
                        end
                        if hasSecretPets then break end
                    end
                end
                
                if not hasSecretPets then
                    task.wait(30)
                    continue
                end
                
                local tradingUI = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Trading
                
                if not (tradingUI and tradingUI.Visible) then
                    while targetPlayer and targetPlayer.Parent ~= nil and AutoTradeSecretPets_Toggle do
                        tradingUI = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Trading
                        if tradingUI and tradingUI.Visible then break end
                        
                        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("TradeRequest", targetPlayer)
                        task.wait(3)
                    end
                end
                
                tradingUI = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Trading
                if tradingUI and tradingUI.Visible then
                    local tradePartnerName = tradingUI.Frame.Top.Them.Username.Text
                    if string.sub(tradePartnerName, 1, 1) == "@" then
                        tradePartnerName = string.sub(tradePartnerName, 2)
                    end
                    
                    if tradePartnerName == targetTradeName then
                        local allPetsAdded = false
                        local petCount = 0
                        
                        while not allPetsAdded and petCount < 10 do
                            local currentPetData = LocalDataService:Get()
                            
                            local tradeContent = tradingUI.Frame.Inner.Offers.You.Content
                            local petIDsInTrade = {}
                            petCount = 0
                            
                            for _, item in pairs(tradeContent:GetChildren()) do
                                if item:IsA("Frame") and not string.match(item.Name, "^Blank%d+$") and not string.match(item.Name, "^Entry%d+$") then
                                    petIDsInTrade[item.Name] = true
                                    petCount = petCount + 1
                                end
                            end
                            
                            if petCount >= 10 then
                                allPetsAdded = true
                                break
                            end
                            
                            local foundPetToAdd = false
                            local petIdToAdd = nil
                            
                            if currentPetData and currentPetData.Pets then
                                for _, pet in pairs(currentPetData.Pets) do
                                    local isSecretPet = false
                                    for _, secretPetName in pairs(SecretPets) do
                                        if pet.Name == secretPetName then
                                            isSecretPet = true
                                            break
                                        end
                                    end
                                    
                                    if isSecretPet then
                                        if pet.Amount then
                                            for i = 1, pet.Amount do
                                                local fullPetId = pet.Id .. ":" .. i
                                                if not petIDsInTrade[fullPetId] then
                                                    petIdToAdd = fullPetId
                                                    foundPetToAdd = true
                                                    break
                                                end
                                            end
                                        else
                                            local fullPetId = pet.Id .. ":0"
                                            if not petIDsInTrade[fullPetId] then
                                                petIdToAdd = fullPetId
                                                foundPetToAdd = true
                                            end
                                        end
                                        
                                        if foundPetToAdd then
                                            break
                                        end
                                    end
                                end
                            end
                            
                            if foundPetToAdd and petIdToAdd then
                                local beforeCount = petCount
                                
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("TradeAddPet", petIdToAdd)
                                task.wait(1)
                                
                                local tradeContent = tradingUI.Frame.Inner.Offers.You.Content
                                local afterCount = 0
                                
                                for _, item in pairs(tradeContent:GetChildren()) do
                                    if item:IsA("Frame") and not string.match(item.Name, "^Blank%d+$") and not string.match(item.Name, "^Entry%d+$") then
                                        afterCount = afterCount + 1
                                    end
                                end
                                
                                petCount = afterCount
                                
                                if afterCount <= beforeCount then
                                    task.wait(0.5)
                                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("TradeAddPet", petIdToAdd)
                                    task.wait(1)
                                end
                            else
                                allPetsAdded = true
                            end
                        end
                        
                        local finalTradeContent = tradingUI.Frame.Inner.Offers.You.Content
                        local finalPetCount = 0
                        
                        for _, item in pairs(finalTradeContent:GetChildren()) do
                            if item:IsA("Frame") and not string.match(item.Name, "^Blank%d+$") and not string.match(item.Name, "^Entry%d+$") then
                                finalPetCount = finalPetCount + 1
                            end
                        end
                        
                        if finalPetCount > 0 then
                            task.wait(1)
                            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("TradeAccept")
                            
                            task.wait(1)
                            local acceptButtonText = tradingUI.Frame.Inner.Offers.Buttons.Accept.Button.Label.Text
                            
                            if acceptButtonText == "Confirm" then
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("TradeConfirm")
                            end
                            
                            task.wait(5)
                        end
                    end
                end
                
                task.wait(1)
            end
        end)
    else
        if tradeThread then
            task.cancel(tradeThread)
            tradeThread = nil
        end
    end
    
    return AutoTradeSecretPets_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Secret Check ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function checkForSecretPets()
    local freshPetData = LocalDataService:Get()
    local foundSecretPet = false
    local secretPetCounts = {}
    local playerName = game:GetService("Players").LocalPlayer.Name
    
    if freshPetData and freshPetData.Pets then
        for _, pet in pairs(freshPetData.Pets) do
            for _, secretPetName in pairs(SecretPets) do
                if pet.Name == secretPetName then
                    secretPetCounts[secretPetName] = (secretPetCounts[secretPetName] or 0) + 1
                    foundSecretPet = true
                end
            end
        end
    end
    
    if foundSecretPet then
        if not SecretPetOverlay then
            SecretPetOverlay = Instance.new("ScreenGui")
            SecretPetOverlay.Name = "SecretPetOverlay"
            SecretPetOverlay.ResetOnSpawn = false
            SecretPetOverlay.IgnoreGuiInset = true
            SecretPetOverlay.DisplayOrder = 99
            
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
            frame.BackgroundTransparency = 0
            frame.BorderSizePixel = 0
            frame.Name = "SecretFrame"
            frame.Parent = SecretPetOverlay
            
            local playerNameLabel = Instance.new("TextLabel")
            playerNameLabel.Size = UDim2.new(1, 0, 0, 60)
            playerNameLabel.Position = UDim2.new(0, 0, 0.1, 0)
            playerNameLabel.BackgroundTransparency = 1
            playerNameLabel.Font = Enum.Font.SourceSansBold
            playerNameLabel.TextSize = 140
            playerNameLabel.TextWrapped = true
            playerNameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            playerNameLabel.Text = "PLAYER: " .. string.upper(playerName)
            playerNameLabel.TextStrokeTransparency = 0
            playerNameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            playerNameLabel.Name = "PlayerName"
            playerNameLabel.Parent = frame
            
            local scrollFrame = Instance.new("ScrollingFrame")
            scrollFrame.Size = UDim2.new(0.8, 0, 0.5, 0)
            scrollFrame.Position = UDim2.new(0.1, 0, 0.25, 0)
            scrollFrame.BackgroundTransparency = 1
            scrollFrame.ScrollBarThickness = 6
            scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
            scrollFrame.Name = "PetList"
            scrollFrame.Parent = frame
            
            SecretPetOverlay.Parent = game:GetService("CoreGui")
        else
            SecretPetOverlay.SecretFrame.PlayerName.Text = "PLAYER: " .. string.upper(playerName)
        end
        
        local scrollFrame = SecretPetOverlay.SecretFrame.PetList
        
        for _, child in pairs(scrollFrame:GetChildren()) do
            if child:IsA("TextLabel") then
                child:Destroy()
            end
        end
        
        local yPosition = 0
        for petName, count in pairs(secretPetCounts) do
            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 0, 70)
            textLabel.Position = UDim2.new(0, 0, 0, yPosition)
            textLabel.BackgroundTransparency = 1
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.TextSize = 140
            textLabel.TextWrapped = true
            textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            textLabel.Text = string.upper(petName) .. " x" .. count
            textLabel.TextStrokeTransparency = 0
            textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            textLabel.Parent = scrollFrame
            
            yPosition = yPosition + 80
        end
        
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, yPosition)
        
        if not AutoTradeSecretPets_Toggle then
            autoTradeSecretPets()
        end
        
        task.wait(5)
        return true
    else
        if SecretPetOverlay then
            SecretPetOverlay:Destroy()
            SecretPetOverlay = nil
        end
        
        if AutoTradeSecretPets_Toggle then
            autoTradeSecretPets()
        end
        
        task.wait(10)
        return false
    end
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Handle Intro ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local IntroHandling_Toggle = false
local hasHandledIntro = false

local function SimulateIntroPlayButtonClick()
    local IntroPlayButton = game:GetService("Players").LocalPlayer.PlayerGui.Intro.Play.Button
    IntroPlayButton:SetAttribute("Pressed", true)
    task.wait(0.1)
    IntroPlayButton:SetAttribute("Pressed", false)
end

local function SimulateOptimizedButtonClick()
    local Optimized = game:GetService("Players").LocalPlayer.PlayerGui.Intro.Graphics.Content.Low.Action.Button
    Optimized:SetAttribute("Pressed", true)
    task.wait(0.1)
    Optimized:SetAttribute("Pressed", false)
end

local function handleIntro()
    if IntroHandling_Toggle then
        return hasHandledIntro
    end
    
    IntroHandling_Toggle = true
    
    while true do
        local success, introStillActive = pcall(function()
            local Intro = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Intro")
            
            if Intro and Intro.Enabled then
                if Intro.Play.Visible == true then
                    task.wait(5)
                    SimulateIntroPlayButtonClick()
                    task.wait(1)
                end
                
                if Intro.Graphics.Visible == true then
                    SimulateOptimizedButtonClick()
                    task.wait(1)
                end
                
                SimulateIntroPlayButtonClick()
                task.wait(0.5)
                SimulateOptimizedButtonClick()
                
                return true
            end
            
            return false
        end)
        
        if success and not introStillActive then
            hasHandledIntro = true
            break
        end
        
        task.wait(2)
    end
    
    IntroHandling_Toggle = false
    
    return hasHandledIntro
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Daily Rewards Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local CheckRewards_Toggle = false
local hasClaimedDailyReward = false
local startCheckTime = nil

local function SimulateShopCloseButtonClick()
    local ShopClose = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.DailyRewards.Shop.Top.Close.Button
    ShopClose:SetAttribute("Pressed", true)
    task.wait(0.1)
    ShopClose:SetAttribute("Pressed", false)
end

local function checkDailyRewards()
    CheckRewards_Toggle = not CheckRewards_Toggle
    
    if CheckRewards_Toggle then
        startCheckTime = os.time()
        
        spawn(function()
            while CheckRewards_Toggle do
                if os.time() - startCheckTime > 300 then
                    CheckRewards_Toggle = false
                    return false
                end
                
                local success, result = pcall(function()
                    local dailyRewardsUI = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.DailyRewards
                    
                    if dailyRewardsUI and dailyRewardsUI.Login and dailyRewardsUI.Login.Visible == true then
                        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("DailyRewardClaimStars")
                        task.wait(1)
                        
                        if dailyRewardsUI.Shop and dailyRewardsUI.Shop.Visible == true then
                            SimulateShopCloseButtonClick()
                            task.wait(0.5)
                        end
                        
                        CheckRewards_Toggle = false
                        hasClaimedDailyReward = true
                        return true
                    end
                    
                    task.wait(1)
                    return false
                end)
                
                if not success then
                    CheckRewards_Toggle = false
                    return false
                end
            end
        end)
    end
    
    return hasClaimedDailyReward
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Claim Playtime ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoClaimPlaytime_Toggle = false
local autoClaimingPlaytimeThread = nil
local PlaytimeRewardsClaimed = false

local function toggleAutoClaimPlaytime()
    if PlaytimeRewardsClaimed then
        return PlaytimeRewardsClaimed
    end
    
    AutoClaimPlaytime_Toggle = not AutoClaimPlaytime_Toggle
    
    if AutoClaimPlaytime_Toggle then
        autoClaimingPlaytimeThread = spawn(function()
            while AutoClaimPlaytime_Toggle do
                local Playtime = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Playtime
                
                if Playtime and Playtime:FindFirstChild("Frame") and Playtime.Frame:FindFirstChild("Main") then
                    local Main = Playtime.Frame.Main
                    local allClaimed = true
                    local foundAnyRewards = false
                    local anyPending = false
                    
                    for _, child in pairs(Main:GetChildren()) do
                        if tonumber(child.Name) then
                            foundAnyRewards = true
                            local rewardNumber = tonumber(child.Name)
                            local button = child:FindFirstChild("Button")
                            local completed = child:FindFirstChild("Completed")
                            
                            if button and completed then
                                local label = button:FindFirstChild("Label")
                                
                                if label and label.Text == "Open" and not completed.Visible then
                                    allClaimed = false
                                    
                                    local success, result = pcall(function()
                                        return game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Function:InvokeServer("ClaimPlaytime", rewardNumber)
                                    end)
                                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimSeason")
                                    task.wait(1)
                                end
                                
                                if completed.Visible and (not label or not label.Visible) then
                                end
                                
                                if not completed.Visible and label and label.Text ~= "Open" then
                                    allClaimed = false
                                    anyPending = true
                                end
                            end
                        end
                    end
                    
                    if foundAnyRewards and allClaimed and not anyPending then
                        PlaytimeRewardsClaimed = true
                        AutoClaimPlaytime_Toggle = false
                        break
                    end
                end
                
                task.wait(30)
            end
        end)
    end
    
    return AutoClaimPlaytime_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Claim Prizes Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoClaimPrizes_Toggle = false
local autoClaimingPrizeThread = nil

local function CheckAndClaimPrizes()
    local Prizes = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Quests.Frame.Main.Prizes
    
    for _, prizeItem in pairs(Prizes:GetChildren()) do
        
        local Content = prizeItem:FindFirstChild("Content")
        if Content then
            local Bar = Content:FindFirstChild("Bar")
            local Claim = Content:FindFirstChild("Claim")
            
            if Bar and Claim and Bar:FindFirstChild("Label") and Claim:FindFirstChild("Button") then
                local progressText = Bar.Label.Text
                local ClaimButton = Claim.Button
                
                if progressText == "100%" and Claim.Visible then

                    ClaimButton:SetAttribute("Pressed", true)
                    task.wait(0.1)
                    ClaimButton:SetAttribute("Pressed", false)
                    
                    return true
                end
            end
        end
    end

    return false
end

local function checkAllTabsForPrizes()
    local PlayerGui = game:GetService("Players").LocalPlayer.PlayerGui
    local QuestsFrame = PlayerGui.ScreenGui.Quests.Frame
    local Sidebar = QuestsFrame.Sidebar
    
    local hasClaimedAny = false
    local keepChecking = true
    
    while keepChecking do
        keepChecking = false
        
        local BubblesButton = Sidebar.Buttons.Bubbles.Button
        local EggsButton = Sidebar.Buttons.Eggs.Button
        local QuestsButton = Sidebar.Buttons.Quests.Button
        
        local BubblesNotification = BubblesButton:FindFirstChild("Notification")
        if BubblesNotification and BubblesNotification.Visible then
            BubblesButton:SetAttribute("Pressed", true)
            task.wait(0.1)
            BubblesButton:SetAttribute("Pressed", false)
            task.wait(1)
            
            local claimed = CheckAndClaimPrizes()
            if claimed then 
                hasClaimedAny = true
                keepChecking = true
                task.wait(0.5)
                continue 
            end
        end
        
        local EggsNotification = EggsButton:FindFirstChild("Notification")
        if EggsNotification and EggsNotification.Visible then
            EggsButton:SetAttribute("Pressed", true)
            task.wait(0.1)
            EggsButton:SetAttribute("Pressed", false)
            task.wait(1)
            
            local claimed = CheckAndClaimPrizes()
            if claimed then 
                hasClaimedAny = true
                keepChecking = true
                task.wait(0.5)
                continue
            end
        end
        
        local QuestsNotification = QuestsButton:FindFirstChild("Notification")
        if QuestsNotification and QuestsNotification.Visible then
            QuestsButton:SetAttribute("Pressed", true)
            task.wait(0.1)
            QuestsButton:SetAttribute("Pressed", false)
            task.wait(1)
            
            local claimed = CheckAndClaimPrizes()
            if claimed then 
                hasClaimedAny = true
                keepChecking = true
                task.wait(0.5)
                continue
            end
        end
    end
    
    local QuestsButton = Sidebar.Buttons.Quests.Button
    QuestsButton:SetAttribute("Pressed", true)
    task.wait(0.1)
    QuestsButton:SetAttribute("Pressed", false)
    
    return hasClaimedAny
end

local function toggleAutoClaimPrizes()
    AutoClaimPrizes_Toggle = not AutoClaimPrizes_Toggle
    
    if AutoClaimPrizes_Toggle then
        autoClaimingPrizeThread = spawn(function()
            while AutoClaimPrizes_Toggle do
                checkAllTabsForPrizes()
                task.wait(60)
            end
        end)
    end
    
    return AutoClaimPrizes_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Wheel Spin Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoWheelSpin_Toggle = false
local autoSpinningWheelThread = nil

local function WheelSpinButtonClick()
    local WheelSpin = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.WheelSpin.Frame.Main.Spin.Button
    WheelSpin:SetAttribute("Pressed", true)
    task.wait(0.1)
    WheelSpin:SetAttribute("Pressed", false)
end

local function toggleAutoWheelSpin()
    AutoWheelSpin_Toggle = not AutoWheelSpin_Toggle
    
    if AutoWheelSpin_Toggle then
        autoSpinningWheelThread = spawn(function()
            while AutoWheelSpin_Toggle do
                local shouldContinueSpinning = false
                
                pcall(function()
                    local freshData = LocalDataService:Get()
                    
                    local spinTickets = freshData.Powerups and freshData.Powerups["Spin Ticket"] or 0
                    
                    local wheelSpinUI = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.WheelSpin
                    
                    if wheelSpinUI and wheelSpinUI.Frame and wheelSpinUI.Frame.Main then
                        local Main = wheelSpinUI.Frame.Main
                        
                        if Main.Buttons and Main.Buttons.Free and 
                           Main.Buttons.Free.Button and 
                           Main.Buttons.Free.Button.Title and 
                           Main.Buttons.Free.Button.Title.Text == "Claim" then
                            
                            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimFreeWheelSpin")
                            task.wait(1)
                            
                            freshData = LocalDataService:Get()
                            spinTickets = freshData.Powerups and freshData.Powerups["Spin Ticket"] or 0
                        end
                    end
                    
                    if spinTickets > 0 then

                        WheelSpinButtonClick()
                        task.wait(15)
                        
                        freshData = LocalDataService:Get()
                        spinTickets = freshData.Powerups and freshData.Powerups["Spin Ticket"] or 0
                        
                        if spinTickets > 0 then
                            shouldContinueSpinning = true
                        end
                    end
                end)
                
                if shouldContinueSpinning then
                    task.wait(0.1)
                else
                    task.wait(60)
                end
            end
        end)
    end
    
    return AutoWheelSpin_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Set Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local SetSettings_Toggle = false
local SettingsThread = nil
local settingsApplied = false

local function SetOptimalSettings()
    if settingsApplied then
        return settingsApplied
    end

    SetSettings_Toggle = not SetSettings_Toggle
    
    if SetSettings_Toggle then
        SettingsThread = spawn(function()
            local optimalSettings = {
                ["Hide Bubbles"] = true,
                ["Hide Others Pets"] = true,
                ["Hide All Pets"] = true,
                ["Compact Pet Inventory"] = true,
                ["Skip Easy Legendary"] = true,
                ["Music"] = 0,
                ["Sound Effects"] = 0
            }
            
            local maxRetries = 3
            local retryCount = 0
            
            while retryCount < maxRetries and SetSettings_Toggle do
                local data = LocalDataService:Get()
                local Settings = data.Settings or {}
                
                local settingsToApply = {}
                local allSettingsMatch = true
                
                for setting, value in pairs(optimalSettings) do
                    if Settings[setting] == nil then
                        continue
                    end
                    
                    local settingMatches = false
                    
                    if setting == "Music" or setting == "Sound Effects" then
                        settingMatches = Settings[setting] <= 1
                    else
                        settingMatches = Settings[setting] == value
                    end
                    
                    if not settingMatches then
                        allSettingsMatch = false
                        table.insert(settingsToApply, {setting = setting, value = value})
                    end
                end
                
                if allSettingsMatch then
                    break
                end
                
                for _, settingData in ipairs(settingsToApply) do
                    Remote.Event:FireServer("SetSetting", settingData.setting, settingData.value)
                    task.wait(0.3)
                end
                
                task.wait(1.5)
                
                retryCount = retryCount + 1
            end
            
            SetSettings_Toggle = false
            settingsApplied = true
        end)
    end
    
    return settingsApplied
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Hide Overlay ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoHideOverlay_Toggle = false
local autoHidingOverlayThread = nil

local function toggleAutoHideOverlay()
    AutoHideOverlay_Toggle = not AutoHideOverlay_Toggle
    
    if AutoHideOverlay_Toggle then
        autoHidingOverlayThread = spawn(function()
            while AutoHideOverlay_Toggle do
                pcall(function()
                    local overlay = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("_overlay")
                    local dailyRWD = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("DailyRewards")
                    local PlyTime = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("Playtime")
                    local Mstry = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("Mastery")
                    local Qust = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("Quests")
                    local Sesson = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("Season")
                    local NotifGame = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("HUD") and 
                                    game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.HUD:FindFirstChild("NotifyGame")
                    local Prompts = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("Prompt")
                    local WorldMp = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("WorldMap")
                    local UpdateNews = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("_changelog")

                    if WorldMp and WorldMp.Visible then
                        WorldMp.Visible = false
                    end

                    if overlay and overlay.Visible then
                        overlay.Visible = false
                    end

                    if dailyRWD and dailyRWD.Visible then
                        dailyRWD.Visible = false
                    end

                    if PlyTime and PlyTime.Visible then
                        PlyTime.Visible = false
                    end

                    if Mstry and Mstry.Visible then
                        Mstry.Visible = false
                    end

                    if Qust and Qust.Visible then
                        Qust.Visible = false
                    end

                    if Sesson and Sesson.Visible then
                        Sesson.Visible = false
                    end

                    if NotifGame and NotifGame.Visible then
                        NotifGame.Visible = false
                    end

                    if Prompts and Prompts.Visible then
                        Prompts.Visible = false
                    end

                    if UpdateNews and UpdateNews.Visible then
                        UpdateNews.Visible = false
                    end

                end)
                
                task.wait(20)
            end
        end)
    end
    
    return AutoHideOverlay_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Fly ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isFlyModeActive = false
local flyModeThread = nil

local function toggleFlyMode()
    isFlyModeActive = not isFlyModeActive
    
    if isFlyModeActive then
        flyModeThread = spawn(function()
            while isFlyModeActive do
                pcall(function()
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    if not character then return end
                    
                    local humanoid = character:FindFirstChild("Humanoid")
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    if not humanoid or not rootPart then return end
                    
                    local camera = workspace.CurrentCamera
                    local UIS = game:GetService("UserInputService")
                    local flySpeed = humanoid.WalkSpeed * 0.9
                    
                    local Gyro = rootPart:FindFirstChild("Gyro")
                    if not Gyro then
                        Gyro = Instance.new("BodyGyro")
                        Gyro.Name = "Gyro"
                        Gyro.P = 9e4
                        Gyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
                        Gyro.Parent = rootPart
                    end
                    
                    local Velocity = rootPart:FindFirstChild("BodyVelocity")
                    if not Velocity then
                        Velocity = Instance.new("BodyVelocity")
                        Velocity.Name = "BodyVelocity"
                        Velocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                        Velocity.Velocity = Vector3.zero
                        Velocity.Parent = rootPart
                    end
                    
                    humanoid.PlatformStand = true
                    
                    Gyro.CFrame = CFrame.new(rootPart.Position, rootPart.Position + camera.CFrame.LookVector)
                    
                    local moveDir = Vector3.new(0,0,0)
                    if UIS:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + camera.CFrame.LookVector end
                    if UIS:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - camera.CFrame.LookVector end
                    if UIS:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - camera.CFrame.RightVector end
                    if UIS:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + camera.CFrame.RightVector end
                    if UIS:IsKeyDown(Enum.KeyCode.E) then moveDir = moveDir + Vector3.new(0,1,0) end
                    if UIS:IsKeyDown(Enum.KeyCode.Q) then moveDir = moveDir - Vector3.new(0,1,0) end
                    
                    if moveDir.Magnitude > 0 then moveDir = moveDir.Unit * flySpeed end
                    Velocity.Velocity = moveDir
                end)
                
                task.wait(0.1)
            end
        end)
    else
        pcall(function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                
                if humanoid then humanoid.PlatformStand = false end
                
                if rootPart then
                    local Gyro = rootPart:FindFirstChild("Gyro")
                    local Velocity = rootPart:FindFirstChild("BodyVelocity")
                    
                    if Gyro then Gyro:Destroy() end
                    if Velocity then Velocity:Destroy() end
                end
            end
        end)
    end
    
    return isFlyModeActive
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Press B ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isPressingB = false
local pressingBThread = nil

local function togglePeriodicB()
    isPressingB = not isPressingB
    
    if isPressingB then
        pressingBThread = spawn(function()
            while isPressingB do
                VIM:SendKeyEvent(true, "B", false, game)
                task.wait(0.01)
                VIM:SendKeyEvent(false, "B", false, game)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("BeginSeasonInfinite")
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ChallengePassClaimAll")
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 1, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 2, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 3, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 4, 2)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 5, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 6, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 7, 2)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 8, 2)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 9, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 10, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimCompetitivePrize", 11, 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Giant Chest", true)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Void Chest", true)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UnlockHatchingZone")
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimSeason")
                task.wait(1)   
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("DoggyJumpWin", 1)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("DoggyJumpWin", 2)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("DoggyJumpWin", 3)
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Void Chest")
                task.wait(1)
                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimChest", "Giant Chest")
                task.wait(5)
                
                task.wait(180)
            end
        end)
    end
    
    return isPressingB
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Mastery Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function SimulateMasteryBuffButtonClick()
    local BuffButton = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Mastery.Container.Left.ScrollingFrame.Buffs.Button
    BuffButton:SetAttribute("Pressed", true)
    task.wait(0.1)
    BuffButton:SetAttribute("Pressed", false)
end

local function SimulateMasteryPetButtonClick()
    local PetButton = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Mastery.Container.Left.ScrollingFrame.Pets.Button
    PetButton:SetAttribute("Pressed", true)
    task.wait(0.1)
    PetButton:SetAttribute("Pressed", false)
end

local function SimulateMasteryShopButtonClick()
    local ShopButton = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Mastery.Container.Left.ScrollingFrame.Shops.Button
    ShopButton:SetAttribute("Pressed", true)
    task.wait(0.1)
    ShopButton:SetAttribute("Pressed", false)
end

local function FindAvailableAndMastery()
    isAutoMastery = not isAutoMastery
    
    if isAutoMastery then
        autoMasteryThread = spawn(function()
            while isAutoMastery do
                local freshData = LocalDataService:Get()
                
                local masteryLevels = {Pets = 0, Buffs = 0, Shops = 0}
                
                if freshData.MasteryLevels and type(freshData.MasteryLevels) == "table" then
                    if freshData.MasteryLevels.Pets ~= nil then
                        masteryLevels = {
                            Pets = freshData.MasteryLevels.Pets or 0,
                            Buffs = freshData.MasteryLevels.Buffs or 0,
                            Shops = freshData.MasteryLevels.Shops or 0
                        }
                    end
                end
                
                PetsMasteryCompleted = (masteryLevels.Pets or 0) >= Target_Pets_Mastery
                BuffsMasteryCompleted = (masteryLevels.Buffs or 0) >= Target_Buffs_Mastery
                ShopsMasteryCompleted = (masteryLevels.Shops or 0) >= Target_Shops_Mastery
                AllMasteryCompleted = PetsMasteryCompleted and BuffsMasteryCompleted and ShopsMasteryCompleted
                
                local upgradePets = not PetsMasteryCompleted
                local upgradeBuffs = PetsMasteryCompleted and not BuffsMasteryCompleted
                local upgradeShops = PetsMasteryCompleted and BuffsMasteryCompleted and not ShopsMasteryCompleted
                
                local function attemptUpgradesInCategory()
                    local MasteryFrame = game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.Mastery
                    
                    if not (MasteryFrame and MasteryFrame.Container and 
                            MasteryFrame.Container.Right and 
                            MasteryFrame.Container.Right.ScrollingFrame) then
                        return false
                    end
                    
                    local ScrollingFrame = MasteryFrame.Container.Right.ScrollingFrame
                    local madeUpgrade = false
                    
                    for _, template in pairs(ScrollingFrame:GetChildren()) do
                        if template.Name == "Template" then
                            local Content = template:FindFirstChild("Content")
                            if Content then
                                local Purchase = Content:FindFirstChild("Purchase")
                                if Purchase then
                                    local Button = Purchase:FindFirstChild("Button")
                                    if Button then
                                        local Label = Button:FindFirstChild("Label")
                                        if Label and Label.Text then
                                            if Label.Text == "FREE" or Label.Text == "0" then
                                                Button:SetAttribute("Pressed", true)
                                                task.wait(0.1)
                                                Button:SetAttribute("Pressed", false)
                                                madeUpgrade = true
                                                task.wait(0.2)
                                                return true
                                            end
                                            
                                            local isCoinPrice = true
                                            local isGemPrice = false
                                            
                                            for _, child in pairs(Button:GetChildren()) do
                                                if child:IsA("ImageLabel") or child:IsA("ImageButton") then
                                                    if child.Image and child.Image:match("122003296498191") then
                                                        isCoinPrice = false
                                                        isGemPrice = true
                                                        break
                                                    elseif child.Image and child.Image:match("121401017387099") then
                                                        isCoinPrice = true
                                                        isGemPrice = false
                                                        break
                                                    end
                                                end
                                            end
                                            
                                            local price = convertPriceToNumber(Label.Text)
                                            
                                            local currentCoins = GetCurrentCoins()
                                            local currentGems = GetCurrentGems()
                                            
                                            local canAfford = false
                                            if isCoinPrice and currentCoins >= price then
                                                canAfford = true
                                            elseif isGemPrice and currentGems >= price then
                                                canAfford = true
                                            end
                                            
                                            if canAfford then
                                                Button:SetAttribute("Pressed", true)
                                                task.wait(0.1)
                                                Button:SetAttribute("Pressed", false)
                                                madeUpgrade = true
                                                task.wait(0.2)
                                                return true
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    
                    return madeUpgrade
                end
                
                if upgradePets then
                    SimulateMasteryPetButtonClick()
                    task.wait(0.5)
                    attemptUpgradesInCategory()
                elseif upgradeBuffs then
                    SimulateMasteryBuffButtonClick()
                    task.wait(0.5)
                    attemptUpgradesInCategory()
                elseif upgradeShops then
                    SimulateMasteryShopButtonClick()
                    task.wait(0.5)
                    attemptUpgradesInCategory()
                else
                    
                    SimulateMasteryPetButtonClick()
                    task.wait(0.5)
                    local upgradedPets = attemptUpgradesInCategory()
                    
                    if not upgradedPets then
                        SimulateMasteryBuffButtonClick()
                        task.wait(0.5)
                        local upgradedBuffs = attemptUpgradesInCategory()
                        
                        if not upgradedBuffs then
                            SimulateMasteryShopButtonClick()
                            task.wait(0.5)
                            attemptUpgradesInCategory()
                        end
                    end
                end
                
                task.wait(10)
            end
        end)
    end
    
    return isAutoMastery
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Reroll Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local RerollEnchants_Toggle = false
local RerollThread = nil

local function hasAnyDesiredEnchant(pet)
    if not pet or not pet.Enchants then return false end
    for _, enchant in ipairs(pet.Enchants) do
        local requiredLevel = enchants[enchant.Id]
        if requiredLevel and enchant.Level >= requiredLevel then
            return true
        end
    end
    return false
end

local function RerollEnchants()
    RerollEnchants_Toggle = not RerollEnchants_Toggle
    
    if RerollEnchants_Toggle then
        RerollThread = spawn(function()
            while RerollEnchants_Toggle do
                local data = LocalDataService:Get()
                local currentTeam = data.Teams[1].Pets
                
                for _, uuid in ipairs(currentTeam) do
                    local pet = getPetById(data, uuid)

                    if pet and not hasAnyDesiredEnchant(pet) then
                        while RerollEnchants_Toggle do
                            Remote.Function:InvokeServer("RerollEnchants", uuid)
                            task.wait(0.2)

                            local updatedData = LocalDataService:Get()
                            pet = getPetById(updatedData, uuid)

                            if hasAnyDesiredEnchant(pet) then
                                break
                            end
                        end
                    end
                end
                
                task.wait(60)
            end
        end)
    end
    
    return RerollEnchants_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Buy Gum and Flavors ━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function get_Highest_Priced_Item(config_table)
    local highest_price = 0
    local highest_item_name = nil
    
    for item_name, item_data in pairs(config_table) do
        if item_data.price > highest_price then
            highest_price = item_data.price
            highest_item_name = item_name
        end
    end
    
    return highest_item_name
end

local max_flavor_item = get_Highest_Priced_Item(flavorsConfig)
local max_gum_item = get_Highest_Priced_Item(gumConfig)

local function AutoBuyItems()
    max_flavor_item = get_Highest_Priced_Item(flavorsConfig)
    max_gum_item = get_Highest_Priced_Item(gumConfig)
    
    AutoBuy_Toggle = not AutoBuy_Toggle
    
    if AutoBuy_Toggle then
        Buy_Thread = spawn(function()
            local freshData = LocalDataService:Get()
            
            if freshData.Flavors and freshData.Flavors[max_flavor_item] then
                max_Flavor_Reached = true
            end
            
            if freshData.Gum and freshData.Gum[max_gum_item] then
                max_Gum_Reached = true
            end
            
            max_Upgrades_Reached = max_Flavor_Reached and max_Gum_Reached
            
            if max_Upgrades_Reached then
                AutoBuy_Toggle = false
                return
            end
            
            while AutoBuy_Toggle do
                local freshData = LocalDataService:Get()
                
                if freshData.Flavors and freshData.Flavors[max_flavor_item] then
                    max_Flavor_Reached = true
                end
                
                if freshData.Gum and freshData.Gum[max_gum_item] then
                    max_Gum_Reached = true
                end
                
                max_Upgrades_Reached = max_Flavor_Reached and max_Gum_Reached
                
                if max_Upgrades_Reached then
                    AutoBuy_Toggle = false
                    break
                end
                
                if not max_Flavor_Reached then
                    local flavors_To_Buy = {}
                    
                    for flavorName, config in pairs(flavorsConfig) do
                        if not freshData.Flavors[flavorName] then
                            table.insert(flavors_To_Buy, {name = flavorName, config = config})
                        end
                    end
                    
                    table.sort(flavors_To_Buy, function(a, b)
                        if a.config.currency == b.config.currency then
                            return a.config.price < b.config.price
                        else
                            return a.config.currency == "Coins"
                        end
                    end)
                    
                    for _, flavorInfo in ipairs(flavors_To_Buy) do
                        local flavorName = flavorInfo.name
                        local config = flavorInfo.config
                        
                        local can_Afford = false
                        if config.currency == "Coins" and GetCurrentCoins() >= config.price then
                            can_Afford = true
                        elseif config.currency == "Gems" and GetCurrentGems() >= config.price then
                            can_Afford = true
                        end
                        
                        if can_Afford then
                            Remote.Event:FireServer("GumShopPurchase", flavorName)
                            
                            task.wait(0.3)
                            
                            freshData = LocalDataService:Get()
                            
                            if freshData.Flavors and freshData.Flavors[max_flavor_item] then
                                max_Flavor_Reached = true
                            end
                            
                            task.wait(0.5)
                        end
                    end
                end
                
                if not max_Gum_Reached then
                    local gums_To_Buy = {}
                    freshData = LocalDataService:Get()
                    
                    for gumName, config in pairs(gumConfig) do
                        if not freshData.Gum[gumName] then
                            table.insert(gums_To_Buy, {name = gumName, config = config})
                        end
                    end
                    
                    table.sort(gums_To_Buy, function(a, b)
                        if a.config.currency == b.config.currency then
                            return a.config.price < b.config.price
                        else
                            return a.config.currency == "Coins"
                        end
                    end)
                    
                    for _, gumInfo in ipairs(gums_To_Buy) do
                        local gumName = gumInfo.name
                        local config = gumInfo.config
                        
                        local can_Afford = false
                        if config.currency == "Coins" and GetCurrentCoins() >= config.price then
                            can_Afford = true
                        elseif config.currency == "Gems" and GetCurrentGems() >= config.price then
                            can_Afford = true
                        end
                        
                        if can_Afford then
                            Remote.Event:FireServer("GumShopPurchase", gumName)
                            
                            task.wait(0.3)
                            
                            freshData = LocalDataService:Get()
                            
                            if freshData.Gum and freshData.Gum[max_gum_item] then
                                max_Gum_Reached = true
                            end
                            
                            task.wait(0.5)
                        end
                    end
                end
                
                max_Upgrades_Reached = max_Flavor_Reached and max_Gum_Reached
                
                task.wait(5)
            end
        end)
    end
    
    return AutoBuy_Toggle, max_Flavor_Reached, max_Gum_Reached, max_Upgrades_Reached
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Area Unlock Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AreaUnlock_Toggle = false
local AreaThread = nil
local areasUnlocked = false

local function UnlockAreas()
    AreaUnlock_Toggle = not AreaUnlock_Toggle
    
    if AreaUnlock_Toggle then
        AreaThread = spawn(function()
            local player = game:GetService("Players").LocalPlayer
            
            while AreaUnlock_Toggle do
                local freshData = LocalDataService:Get()
                local allAreasUnlocked = true
                local areasToTry = {}
                
                for _, areaName in ipairs(AreaToUnlock) do
                    if type(freshData.AreasUnlocked) ~= "table" or not freshData.AreasUnlocked[areaName] then
                        allAreasUnlocked = false
                        table.insert(areasToTry, areaName)
                    end
                end
                
                if allAreasUnlocked then
                    AreaUnlock_Toggle = false
                    areasUnlocked = true
                    break
                end
                
                for _, areaName in ipairs(areasToTry) do
                    if not AreaUnlock_Toggle then break end
                    
                    local character = player.Character or player.CharacterAdded:Wait()
                    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                    
                    local areaWithoutSpaces = areaName:gsub(" ", "")
                    local areaFolder = workspace.Worlds["The Overworld"].Islands:FindFirstChild(areaName) or 
                                     workspace.Worlds["The Overworld"].Islands:FindFirstChild(areaWithoutSpaces)
                    
                    if areaFolder then
                        local unlockHitbox = nil
                        for _, descendant in ipairs(areaFolder:GetDescendants()) do
                            if descendant.Name == "UnlockHitbox" then
                                unlockHitbox = descendant
                                break
                            end
                        end
                        
                        if unlockHitbox then
                            humanoidRootPart.CFrame = unlockHitbox.CFrame * CFrame.new(0, 15, 0)
                            
                            task.wait(0.1)
                            
                            freshData = LocalDataService:Get()
                            
                            if type(freshData.AreasUnlocked) == "table" and freshData.AreasUnlocked[areaName] then
                            end
                        end
                    end
                    
                    task.wait(0.1)
                end
                
                task.wait(0.5)
            end
        end)
    end
    
    return AreaUnlock_Toggle
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━ Auto Mystery Boxes Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local AutoMysteryBoxes_Toggle = false
local autoMysteryBoxesThread = nil

local function toggleAutoMysteryBoxes()
    AutoMysteryBoxes_Toggle = not AutoMysteryBoxes_Toggle
    
    if AutoMysteryBoxes_Toggle then
        autoMysteryBoxesThread = spawn(function()
            while AutoMysteryBoxes_Toggle do
                pcall(function()
                    local freshData = LocalDataService:Get()
                    
                    local mysteryBoxCount = freshData.Powerups and freshData.Powerups["Mystery Box"] or 0
                    
                    if mysteryBoxCount > 0 then
                        local amountToUse = math.min(mysteryBoxCount, 10)
                        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UseGift", "Mystery Box", amountToUse)
                        task.wait(1)
                        
                        while true do
                            local giftsFolder = workspace.Rendered:FindFirstChild("Gifts")
                            if not giftsFolder or #giftsFolder:GetChildren() == 0 then
                                break
                            end
                            
                            for _, gift in pairs(giftsFolder:GetChildren()) do
                                local giftId = gift.Name
                                
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("ClaimGift", giftId)

                                task.wait(1)
                                
                                gift:Destroy()
                                
                                task.wait(0.01)
                            end
                        end
                    end
                end)
                
                task.wait(30)
            end
        end)
    end
    
    return AutoMysteryBoxes_Toggle
end


-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Buy Shop Settings ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoBuyingShopItems = false
local autoBuyingShopItemsThread = nil

local function toggleAutoBuyShopItems()
    isAutoBuyingShopItems = not isAutoBuyingShopItems
    
    if isAutoBuyingShopItems then
        
        autoBuyingShopItemsThread = spawn(function()
            while isAutoBuyingShopItems do
                local shops = {
                    ["alien-shop"] = {1, 2, 3},
                    ["shard-shop"] = {1, 2, 3}
                }
                
                local currentGems = GetCurrentGems()
                if currentGems < Low_Gems then
                    task.wait(60)
                    continue
                end
                
                for shopName, items in pairs(shops) do
                    for _, itemId in ipairs(items) do
                        if GetCurrentGems() >= Low_Gems then
                            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                "BuyShopItem", 
                                shopName, 
                                itemId
                            )
                            task.wait(0.5)
                        else
                            task.wait(30)
                            break
                        end
                    end
                    
                    if not isAutoBuyingShopItems then 
                        break 
                    end
                    
                    task.wait(0.5)
                end
                
                task.wait(60)
            end
        end)
    else
        if autoBuyingShopItemsThread then
            task.cancel(autoBuyingShopItemsThread)
            autoBuyingShopItemsThread = nil
        end
    end
    
    return isAutoBuyingShopItems
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Delete Pets ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoDeletingPets = false
local autoDeletingPetsThread = nil

local function toggleAutoPetDeletion()
    isAutoDeletingPets = not isAutoDeletingPets
    
    if isAutoDeletingPets then
        autoDeletingPetsThread = spawn(function()
            while isAutoDeletingPets do
                pcall(function()
                    local freshData = LocalDataService:Get()
                    
                    local petsInTeams = {}
                    for _, team in ipairs(freshData.Teams) do
                        for _, petId in ipairs(team.Pets) do
                            petsInTeams[petId] = true
                        end
                    end
                    
                    local petsWithShinyVersions = {}
                    
                    for _, petName in ipairs(petsToDelete) do
                        local hasShiny = false
                        for _, pet in ipairs(freshData.Pets) do
                            if pet.Name == petName and pet.Shiny then
                                hasShiny = true
                                break
                            end
                        end
                        
                        if hasShiny then
                            petsWithShinyVersions[petName] = true
                        end
                    end
                    
                    local petsByName = {}
                    
                    for _, pet in ipairs(freshData.Pets) do
                        if petsInTeams[pet.Id] or pet.Locked then
                            continue
                        end
                        
                        local shouldTrack = false
                        for _, petName in ipairs(petsToDelete) do
                            if pet.Name == petName then
                                shouldTrack = true
                                break
                            end
                        end
                        
                        if shouldTrack then
                            if not petsByName[pet.Name] then
                                petsByName[pet.Name] = {
                                    normal = {
                                        pets = {},
                                        count = 0
                                    },
                                    shiny = {
                                        exists = false,
                                        pets = {},
                                        count = 0
                                    }
                                }
                            end
                            
                            if pet.Shiny then
                                petsByName[pet.Name].shiny.exists = true
                                table.insert(petsByName[pet.Name].shiny.pets, pet)
                                petsByName[pet.Name].shiny.count = petsByName[pet.Name].shiny.count + (pet.Amount or 1)
                            else
                                table.insert(petsByName[pet.Name].normal.pets, pet)
                                petsByName[pet.Name].normal.count = petsByName[pet.Name].normal.count + (pet.Amount or 1)
                            end
                        end
                    end
                    
                    for petName, data in pairs(petsByName) do
                        if not data.shiny.exists and data.normal.count >= 16 then
                            local bestCandidate = nil
                            
                            for _, pet in ipairs(data.normal.pets) do
                                if pet.Amount and pet.Amount >= 16 then
                                    bestCandidate = pet
                                    break
                                end
                            end
                            
                            if not bestCandidate and #data.normal.pets > 0 then
                                bestCandidate = data.normal.pets[1]
                            end
                            
                            if bestCandidate then
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                    "MakePetShiny", 
                                    bestCandidate.Id
                                )
                                
                                task.wait(1)
                                
                                freshData = LocalDataService:Get()
                                
                                petsWithShinyVersions[petName] = true
                                
                                petsInTeams = {}
                                for _, team in ipairs(freshData.Teams) do
                                    for _, petId in ipairs(team.Pets) do
                                        petsInTeams[petId] = true
                                    end
                                end
                            end
                        end
                    end
                    
                    local petsByNameAndType = {}
                    
                    for _, pet in ipairs(freshData.Pets) do
                        if petsInTeams[pet.Id] then
                            continue
                        end
                        
                        if pet.Locked then
                            continue
                        end
                        
                        local shouldTrack = false
                        for _, petName in ipairs(petsToDelete) do
                            if pet.Name == petName then
                                shouldTrack = true
                                break
                            end
                        end
                        
                        if shouldTrack and not pet.Shiny then
                            local shinyExists = petsWithShinyVersions[pet.Name] or false
                            if not shinyExists then
                                for _, checkPet in ipairs(freshData.Pets) do
                                    if checkPet.Name == pet.Name and checkPet.Shiny then
                                        shinyExists = true
                                        petsWithShinyVersions[pet.Name] = true
                                        break
                                    end
                                end
                            end
                            
                            if not shinyExists then
                                local totalCount = 0
                                for _, countPet in ipairs(freshData.Pets) do
                                    if countPet.Name == pet.Name and not countPet.Shiny and not petsInTeams[countPet.Id] and not countPet.Locked then
                                        totalCount = totalCount + (countPet.Amount or 1)
                                    end
                                end
                                
                                if totalCount <= 16 then
                                    shouldTrack = false
                                end
                            end
                        end
                        
                        if shouldTrack then
                            local petKey = pet.Name .. (pet.Shiny and "_shiny" or "_normal")
                            
                            if not petsByNameAndType[petKey] then
                                petsByNameAndType[petKey] = {
                                    xpPets = {},
                                    stackedPets = {},
                                    totalCount = 0,
                                    isShiny = pet.Shiny,
                                    name = pet.Name
                                }
                            end
                            
                            if pet.Amount then
                                table.insert(petsByNameAndType[petKey].stackedPets, pet)
                                petsByNameAndType[petKey].totalCount = petsByNameAndType[petKey].totalCount + pet.Amount
                            else
                                table.insert(petsByNameAndType[petKey].xpPets, pet)
                                petsByNameAndType[petKey].totalCount = petsByNameAndType[petKey].totalCount + 1
                            end
                        end
                    end
                    
                    for petKey, petData in pairs(petsByNameAndType) do
                        local threshold = petData.isShiny and shinyKeepThreshold or petKeepThreshold
                        local totalToDelete = petData.totalCount - threshold
                        
                        if totalToDelete > 0 then
                            local refreshNeeded = false
                            
                            for i, xpPet in ipairs(petData.xpPets) do
                                if totalToDelete > 0 then
                                    if not petsInTeams[xpPet.Id] then
                                        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                            "DeletePet", 
                                            xpPet.Id,
                                            1, 
                                            false
                                        )
                                        
                                        totalToDelete = totalToDelete - 1
                                        task.wait(0.3)
                                        refreshNeeded = true
                                        
                                        if i % 3 == 0 or totalToDelete <= 0 then
                                            freshData = LocalDataService:Get()
                                            petsInTeams = {}
                                            for _, team in ipairs(freshData.Teams) do
                                                for _, petId in ipairs(team.Pets) do
                                                    petsInTeams[petId] = true
                                                end
                                            end
                                            refreshNeeded = false
                                        end
                                    end
                                else
                                    break
                                end
                            end
                            
                            if refreshNeeded then
                                freshData = LocalDataService:Get()
                                petsInTeams = {}
                                for _, team in ipairs(freshData.Teams) do
                                    for _, petId in ipairs(team.Pets) do
                                        petsInTeams[petId] = true
                                    end
                                end
                            end
                            
                            if totalToDelete > 0 then
                                local stackedPets = {}
                                for _, pet in ipairs(freshData.Pets) do
                                    local isRightType = pet.Name == petData.name and (pet.Shiny == petData.isShiny)
                                    if isRightType and pet.Amount and not petsInTeams[pet.Id] and not pet.Locked then
                                        table.insert(stackedPets, pet)
                                    end
                                end
                                
                                for i, stackedPet in ipairs(stackedPets) do
                                    if totalToDelete > 0 then
                                        local amountToDelete = math.min(stackedPet.Amount, totalToDelete)
                                        
                                        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                            "DeletePet", 
                                            stackedPet.Id,
                                            amountToDelete, 
                                            false
                                        )
                                        
                                        totalToDelete = totalToDelete - amountToDelete
                                        task.wait(0.3)
                                        
                                        if i % 2 == 0 or totalToDelete <= 0 then
                                            freshData = LocalDataService:Get()
                                            petsInTeams = {}
                                            for _, team in ipairs(freshData.Teams) do
                                                for _, petId in ipairs(team.Pets) do
                                                    petsInTeams[petId] = true
                                                end
                                            end
                                        end
                                    else
                                        break
                                    end
                                end
                            end
                        end
                    end
                    
                    freshData = LocalDataService:Get()
                    
                    for petName in pairs(petsWithShinyVersions) do
                        local isAlreadyAutoDelete = freshData.AutoDelete and freshData.AutoDelete[petName]
                        
                        if not isAlreadyAutoDelete then
                            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                "ToggleAutoDelete", 
                                petName
                            )
                            task.wait(0.2)
                        end
                    end
                end)
                
                task.wait(30)
            end
        end)
    end
    
    return isAutoDeletingPets
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Craft Potion Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local isAutoCraftingPotions = false
local autoCraftingPotionsThread = nil

local function toggleAutoCraftPotions()
    isAutoCraftingPotions = not isAutoCraftingPotions
    
    if isAutoCraftingPotions then
        autoCraftingPotionsThread = spawn(function()
            while isAutoCraftingPotions do
                local currentGems = GetCurrentGems()
                
                if currentGems >= Low_Gems then
                    local madeCraft = false
                    local data = LocalDataService:Get()
                    
                    for tier = 2, 5 do
                        for _, potionType in ipairs(potionTypes) do
                            local sourceTier = tier - 1
                            local required = craftingRequirements[tier]
                            local available = 0
                            
                            for _, potion in ipairs(data.Potions or {}) do
                                if potion.Name == potionType and potion.Level == sourceTier then
                                    available = potion.Amount or 0
                                    break
                                end
                            end
                            
                            if available >= required and GetCurrentGems() >= Low_Gems then
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                    "CraftPotion", potionType, tier, true)
                                madeCraft = true
                                task.wait(0.3)
                                data = LocalDataService:Get()
                            end
                        end
                    end
                    
                    task.wait(madeCraft and 0.5 or 10)
                else
                    task.wait(15)
                end
            end
        end)
    end
    
    return isAutoCraftingPotions
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Use Potion Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function isPotionActive(potionType)
    local freshData = LocalDataService:Get()
    
    if freshData.ActivePotions and 
       type(freshData.ActivePotions) == "table" and
       freshData.ActivePotions[potionType] and 
       freshData.ActivePotions[potionType].Active then
        return true
    end
    
    return false
end

local function getHighestLevelPotion(potionType)
    local freshData = LocalDataService:Get()
    local highestLevel = 0
    local highestLevelPotion = nil
    
    if freshData.Potions and #freshData.Potions > 0 then
        for _, potion in ipairs(freshData.Potions) do
            if potion.Name == potionType and potion.Amount > 0 then
                if potion.Level > highestLevel then
                    highestLevel = potion.Level
                    highestLevelPotion = potion
                end
            end
        end
    end
    
    return highestLevelPotion
end

local function usePotion(potionName, potionLevel)
    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
        "UsePotion", 
        potionName, 
        potionLevel
    )
    
    task.wait(0.3)
    
    return true
end

local function toggleAutoUsePotion()
    isAutoUsingPotions = not isAutoUsingPotions
    
    if isAutoUsingPotions then
        autoUsingPotionsThread = spawn(function()
            while isAutoUsingPotions do
                if isAutoHatching and not tempDisableHatching then
                    for _, potionType in ipairs(priorityPotions) do
                        if not isPotionActive(potionType) then
                            local bestPotion = getHighestLevelPotion(potionType)
                            
                            if bestPotion then
                                usePotion(bestPotion.Name, bestPotion.Level)
                                task.wait(1)
                            end
                        end
                    end
                    
                    if isHatchingX25Egg and not isPotionActive("Infinity Elixir") then
                        local infinityPotion = getHighestLevelPotion("Infinity Elixir")
                        if infinityPotion then
                            usePotion(infinityPotion.Name, infinityPotion.Level)
                            task.wait(1)
                        end
                    end
                end
                
                task.wait(3)
            end
        end)
    end
    
    return isAutoUsingPotions
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━ Auto Collection Buffs Function ━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function useCollectionBuffs()
    local freshData = LocalDataService:Get()
    
    local hasCoinsPotion = false
    if freshData.ActivePotions and type(freshData.ActivePotions) == "table" then
        if freshData.ActivePotions["Coins"] and freshData.ActivePotions["Coins"].Active then
            hasCoinsPotion = true
        end
    end
    
    local hasGoldRush = false
    if freshData.ActiveBuffs and type(freshData.ActiveBuffs) == "table" then
        for _, buff in ipairs(freshData.ActiveBuffs) do
            if buff.Name == "GoldRush" then
                hasGoldRush = true
                break
            end
        end
    end
    
    if not hasCoinsPotion then
        local coinsPotion = getHighestLevelPotion("Coins")
        if coinsPotion then
            usePotion(coinsPotion.Name, coinsPotion.Level)
            task.wait(0.5)
        end
    end
    
    if not hasGoldRush and freshData.Powerups and freshData.Powerups["Golden Orb"] and freshData.Powerups["Golden Orb"] > 0 then
        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UseGoldenOrb")
        task.wait(0.5)
    end
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Collect Pickup ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function toggleAutoCollectPickups()
    isAutoCollectingPickups = not isAutoCollectingPickups
    
    if isAutoCollectingPickups then
        autoCollectingPickupsThread = spawn(function()
            while isAutoCollectingPickups do
                pcall(function()
                    useCollectionBuffs()
                    
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local isInZen = math.abs(humanoidRootPart.Position.Y - 15975) < 30
                            
                            if isInZen then
                                for _, chunkerFolder in pairs(workspace.Rendered:GetChildren()) do
                                    if chunkerFolder.Name == "Chunker" and chunkerFolder:IsA("Folder") then
                                        for _, uuidObject in pairs(chunkerFolder:GetChildren()) do
                                            if typeof(uuidObject) == "Instance" and uuidObject.Name:match("%-") then
                                                local pickupId = uuidObject.Name
                                                game:GetService("ReplicatedStorage").Remotes.Pickups.CollectPickup:FireServer(pickupId)
                                                task.wait(0.05)
                                                uuidObject:Destroy()
                                                task.wait(0.05)
                                            end
                                        end
                                    end
                                end
                            else
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("Teleport", "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn")
                                task.wait(5)
                            end
                        end
                    end
                end)
                
                task.wait(1)
            end
        end)
    end
    
    return isAutoCollectingPickups
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Egg Counter Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function toggleEggCounter()
    isEggCounterEnabled = not isEggCounterEnabled
    
    if isEggCounterEnabled then
        if not EggCounterGui then

            EggCounterGui = Instance.new("ScreenGui")
            EggCounterGui.Name = "EggCounterGui"
            EggCounterGui.ResetOnSpawn = false
            EggCounterGui.IgnoreGuiInset = true
            EggCounterGui.DisplayOrder = 98 
            
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.Position = UDim2.new(0, 0, 0, 0)
            frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            frame.BackgroundTransparency = 0
            frame.BorderSizePixel = 0
            frame.Name = "Frame"
            frame.Parent = EggCounterGui
            
            local titleLabel = Instance.new("TextLabel")
            titleLabel.Size = UDim2.new(1, 0, 0, 50)
            titleLabel.Position = UDim2.new(0, 0, 0.23, 0)
            titleLabel.BackgroundTransparency = 1
            titleLabel.Font = Enum.Font.SourceSansBold
            titleLabel.TextSize = 135
            titleLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            titleLabel.Text = "Hatching Off"
            titleLabel.TextStrokeTransparency = 0
            titleLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            titleLabel.Name = "TitleLabel"
            titleLabel.Parent = frame
            
            local counterLabel = Instance.new("TextLabel")
            counterLabel.Size = UDim2.new(1, 0, 0, 50)
            counterLabel.Position = UDim2.new(0, 0, 0.37, 0)
            counterLabel.BackgroundTransparency = 1
            counterLabel.Font = Enum.Font.SourceSansBold
            counterLabel.TextSize = 125
            counterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            counterLabel.Text = ""
            counterLabel.TextWrapped = true
            counterLabel.TextXAlignment = Enum.TextXAlignment.Center
            counterLabel.TextStrokeTransparency = 0
            counterLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            counterLabel.Name = "CounterLabel"
            counterLabel.Parent = frame
            
            local coinsLabel = Instance.new("TextLabel")
            coinsLabel.Size = UDim2.new(1, 0, 0, 50)
            coinsLabel.Position = UDim2.new(0, 0, 0.52, 0)
            coinsLabel.BackgroundTransparency = 1
            coinsLabel.Font = Enum.Font.SourceSansBold
            coinsLabel.TextSize = 125
            coinsLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
            coinsLabel.Text = "Coins: 0"
            coinsLabel.TextWrapped = true
            coinsLabel.TextXAlignment = Enum.TextXAlignment.Center
            coinsLabel.TextStrokeTransparency = 0
            coinsLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            coinsLabel.Name = "CoinsLabel"
            coinsLabel.Parent = frame
            
            local gemsLabel = Instance.new("TextLabel")
            gemsLabel.Size = UDim2.new(1, 0, 0, 50)
            gemsLabel.Position = UDim2.new(0, 0, 0.65, 0)
            gemsLabel.BackgroundTransparency = 1
            gemsLabel.Font = Enum.Font.SourceSansBold
            gemsLabel.TextSize = 125
            gemsLabel.TextColor3 = Color3.fromRGB(170, 0, 255)
            gemsLabel.Text = "Gems: 0"
            gemsLabel.TextWrapped = true
            gemsLabel.TextXAlignment = Enum.TextXAlignment.Center
            gemsLabel.TextStrokeTransparency = 0
            gemsLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            gemsLabel.Name = "GemsLabel"
            gemsLabel.Parent = frame
            
            EggCounterGui.Parent = game:GetService("CoreGui")
        else
            EggCounterGui.Enabled = true
        end
        
        spawn(function()
            while isEggCounterEnabled and EggCounterGui do
                local playerData = LocalDataService:Get()
                local titleLabel = EggCounterGui.Frame.TitleLabel
                local counterLabel = EggCounterGui.Frame.CounterLabel
                local coinsLabel = EggCounterGui.Frame.CoinsLabel
                local gemsLabel = EggCounterGui.Frame.GemsLabel
                
                if playerData then
                    local currentCoins = GetCurrentCoins()
                    coinsLabel.Text = "Coins: " .. FormatNumberCompact(currentCoins)
                    
                    local currentGems = playerData.Gems or 0
                    gemsLabel.Text = "Gems: " .. FormatNumberCompact(currentGems)
                end
                
                if CurrentlyHatchingEgg and playerData and playerData.EggsOpened then
                    local eggCount = playerData.EggsOpened[CurrentlyHatchingEgg] or 0
                    titleLabel.Text = "Currently Hatching"
                    titleLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                    counterLabel.Text = CurrentlyHatchingEgg .. " : " .. tostring(eggCount)
                else
                    titleLabel.Text = "Hatching Off"
                    titleLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
                    counterLabel.Text = ""
                end
                
                task.wait(1)
                
                if not isEggCounterEnabled then break end
            end
        end)
    else
        if EggCounterGui then
            EggCounterGui.Enabled = false
        end
    end
    
    return isEggCounterEnabled
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Hatch Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function getLuckMultiplier(luckText)
    if not luckText then return 0 end
    
    local multiplier = luckText:match("x(%d+)")
    if multiplier then
        return tonumber(multiplier) or 0
    end
    return 0
end

local function findBestEgg()
    local rifts = workspace.Rendered:FindFirstChild("Rifts")
    if not rifts then return nil end
    
    local availableEggs = {}
    
    for _, eggId in ipairs(eggPriority) do
        local egg = rifts:FindFirstChild(eggId)
        if egg then
            local display = egg:FindFirstChild("Display")
            if display then
                local luckMultiplier = 0
                for _, descendant in ipairs(egg:GetDescendants()) do
                    if descendant.Name == "Luck" and descendant:IsA("TextLabel") and descendant.Text then
                        luckMultiplier = getLuckMultiplier(descendant.Text)
                        break
                    end
                end
                
                table.insert(availableEggs, {
                    eggId = eggId,
                    eggName = eggMapping[eggId],
                    display = display,
                    priority = table.find(eggPriority, eggId) or #eggPriority + 1,
                    luckMultiplier = luckMultiplier
                })
            end
        end
    end
    
    table.sort(availableEggs, function(a, b)
        if a.luckMultiplier == 25 and b.luckMultiplier ~= 25 then
            return true
        elseif a.luckMultiplier ~= 25 and b.luckMultiplier == 25 then
            return false
        elseif a.priority == b.priority then
            return a.luckMultiplier > b.luckMultiplier
        end
        return a.priority < b.priority
    end)
    
    local bestEgg = #availableEggs > 0 and availableEggs[1] or nil
    
    isHatchingX25Egg = bestEgg and bestEgg.luckMultiplier == 25 or false
    
    return bestEgg
end

local function isNearEgg(eggDisplay)
    if not eggDisplay then return false end
    
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end
    
    local distance = (humanoidRootPart.Position - eggDisplay.Position).Magnitude
    return distance < 15
end

local function toggleAutoHatch()
    if not isAutoHatching and not (PetsMasteryCompleted and BuffsMasteryCompleted) then
        return false
    end
    
    isAutoHatching = not isAutoHatching
    
    if isAutoHatching then
        if not isAutoUsingPotions then
            toggleAutoUsePotion()
        end
        
        autoHatchingThread = spawn(function()
            while isAutoHatching do
                pcall(function()
                    local currentCoins = GetCurrentCoins()
                    
                    if currentCoins < Low_Coins then
                        if not isAutoCollectingPickups then
                            toggleAutoCollectPickups()
                            pickupCollectionStartedByHatcher = true
                            tempDisableHatching = true
                        end
                        task.wait(3)
                        return
                    else
                        if currentCoins >= Max_Coins * 0.6 then
                            tempDisableHatching = false
                            
                            if isAutoCollectingPickups and pickupCollectionStartedByHatcher then
                                toggleAutoCollectPickups()
                                pickupCollectionStartedByHatcher = false
                            end
                        else
                            if isAutoCollectingPickups and pickupCollectionStartedByHatcher then
                                task.wait(3)
                                return
                            else
                                tempDisableHatching = false
                            end
                        end
                    end
                    
                    if not tempDisableHatching then
                        local shouldPrioritizeHatching = currentCoins >= Max_Coins * 0.95
                        
                        local bestEgg = findBestEgg()
                        
                        if not bestEgg then
                            local player = game:GetService("Players").LocalPlayer
                            local character = player.Character
                            if character then
                                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                if humanoidRootPart then
                                    local playerPos = humanoidRootPart.Position
                                    local defaultEggY = Default_Egg.Position.Y - 7
                                    
                                    if math.abs(playerPos.Y - defaultEggY) > 10 then
                                        local adjustedCFrame = Default_Egg * CFrame.new(0, -7, 0)
                                        
                                        local horizTween, vertTween = TweenCharacterToTarget(adjustedCFrame)
                                        
                                        if horizTween and vertTween then
                                            horizTween.Completed:Wait()
                                            vertTween.Completed:Wait()
                                        else
                                            task.wait(0.5)
                                        end
                                    end
                                end
                            end
                            
                            local hatchAmount = 8
                            CurrentlyHatchingEgg = "100M Egg"
                            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                "HatchEgg", 
                                "100M Egg",
                                hatchAmount
                            )
                            
                            task.wait(0.05)
                            VIM:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                            task.wait(0.05)
                            VIM:SendKeyEvent(false, Enum.KeyCode.R, false, game)
                            
                            task.wait(0.5)
                        elseif currentCoins >= Low_Coins then
                            local horizTween, vertTween = TweenCharacterToTarget(bestEgg.display)
                            
                            if horizTween and vertTween then
                                horizTween.Completed:Wait()
                                vertTween.Completed:Wait()
                            else
                                task.wait(0.5)
                            end
                            
                            local hatchAmount = 8
                            
                            while GetCurrentCoins() >= Low_Coins do
                                local newBestEgg = findBestEgg()
                                
                                if not newBestEgg then
                                    break
                                elseif newBestEgg.eggId ~= bestEgg.eggId then
                                    bestEgg = newBestEgg
                                    
                                    local newHorizTween, newVertTween = TweenCharacterToTarget(bestEgg.display)
                                    if newHorizTween and newVertTween then
                                        newHorizTween.Completed:Wait()
                                        newVertTween.Completed:Wait()
                                    else
                                        task.wait(0.5)
                                    end
                                end
                                
                                if isNearEgg(bestEgg.display) then
                                    CurrentlyHatchingEgg = bestEgg.eggName
                                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                        "HatchEgg", 
                                        bestEgg.eggName, 
                                        hatchAmount
                                    )
                                    
                                    task.wait(0.05)
                                    VIM:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                                    task.wait(0.05)
                                    VIM:SendKeyEvent(false, Enum.KeyCode.R, false, game)
                                    
                                    task.wait(0.5)
                                    
                                    if GetCurrentCoins() < Low_Coins * 1.1 then
                                        break
                                    end
                                else
                                    break
                                end
                            end
                        end
                    end
                end)
                
                task.wait(0.5)
            end
        end)
    else
        if isAutoUsingPotions then
            toggleAutoUsePotion()
        end
        
        if isAutoCollectingPickups and pickupCollectionStartedByHatcher then
            toggleAutoCollectPickups()
            pickupCollectionStartedByHatcher = false
        end
    end
    
    return isAutoHatching
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Auto Bubble & Sell Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function Auto_Bubble_And_Sell()
    if Auto_Bubble_And_Sell_Active or 
       (AllMasteryCompleted and max_Upgrades_Reached) or 
       isAutoHatching then
        Auto_Bubble_And_Sell_Active = false
        return false
    end
    
    Auto_Bubble_And_Sell_Active = true
    
    Auto_Bubble_And_Sell_Thread = spawn(function()
        while Auto_Bubble_And_Sell_Active do
            game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("BlowBubble")
            
            if isAutoHatching or (AllMasteryCompleted and max_Upgrades_Reached) then
                Auto_Bubble_And_Sell_Active = false
                break
            end
            
            pcall(function()
                local freshData = LocalDataService:Get()
                
                local hasCoinsPotion = false
                if freshData.ActivePotions and type(freshData.ActivePotions) == "table" then
                    if freshData.ActivePotions["Coins"] and freshData.ActivePotions["Coins"].Active then
                        hasCoinsPotion = true
                    end
                end
                
                local hasGoldRush = false
                if freshData.ActiveBuffs and type(freshData.ActiveBuffs) == "table" then
                    for _, buff in ipairs(freshData.ActiveBuffs) do
                        if buff.Name == "GoldRush" then
                            hasGoldRush = true
                            break
                        end
                    end
                end
                
                if not hasCoinsPotion then
                    local coinsPotion = getHighestLevelPotion("Coins")
                    if coinsPotion then
                        usePotion(coinsPotion.Name, coinsPotion.Level)
                        task.wait(0.5)
                    end
                end
                
                if not hasGoldRush and freshData.Powerups and freshData.Powerups["Golden Orb"] and freshData.Powerups["Golden Orb"] > 0 then
                    game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("UseGoldenOrb")
                    task.wait(0.5)
                end
            end)
            
            if max_Flavor_Reached and 
               (not PetsMasteryCompleted or not BuffsMasteryCompleted or not ShopsMasteryCompleted) then
                if not isAutoCollectingPickups then
                    toggleAutoCollectPickups()
                    task.wait(3)
                end
                
            else
                if isAutoCollectingPickups then
                    toggleAutoCollectPickups()
                    task.wait(1)
                end
                
                pcall(function()
                    local player = game:GetService("Players").LocalPlayer
                    local character = player.Character
                    
                    if character then
                        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local playerPos = humanoidRootPart.Position
                            
                            if math.abs(playerPos.Y - 6862) > 30 then
                                game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer(
                                    "Teleport", 
                                    "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn"
                                )
                                task.wait(2)
                            else
                                local sellRoot = workspace.Worlds["The Overworld"].Islands.Twilight.Island.Sell.Root
                                if sellRoot then
                                    local distance = (humanoidRootPart.Position - sellRoot.Position).Magnitude
                                    if distance > 10 then
                                        local horizontalTween, verticalTween = TweenCharacterToTarget(sellRoot)
                                        
                                        if horizontalTween then
                                            horizontalTween.Completed:Wait()
                                        end
                                        
                                        if verticalTween then
                                            verticalTween.Completed:Wait()
                                        end
                                        
                                        task.wait(0.5)
                                    end
                                    
                                    local GuiGum = player.PlayerGui.ScreenGui.HUD.Left.Currency.Bubble.Frame.Label.Text
                                    local current, max = extractNumbers(GuiGum)
                                    
                                    if current and current > 1 then
                                        game:GetService("ReplicatedStorage").Shared.Framework.Network.Remote.Event:FireServer("SellBubble")
                                        task.wait(0.5)
                                    end
                                end
                            end
                        end
                    end
                end)
            end
            
            if (AllMasteryCompleted and max_Upgrades_Reached) or isAutoHatching then
                Auto_Bubble_And_Sell_Active = false
                
                if isAutoCollectingPickups then
                    toggleAutoCollectPickups()
                end
                
                break
            end
            
            task.wait(0.3)
        end
    end)
    
    return Auto_Bubble_And_Sell_Active
end


-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━ Initialize Data Function ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

local function InitializePlayerData()
    local freshData = LocalDataService:Get()
    
    if freshData then
        if freshData.Flavors then
            local max_flavor_item = get_Highest_Priced_Item(flavorsConfig)
            if freshData.Flavors[max_flavor_item] then
                max_Flavor_Reached = true
            else
                max_Flavor_Reached = false
            end
        else
            max_Flavor_Reached = false
        end
        
        if freshData.Gum then
            local max_gum_item = get_Highest_Priced_Item(gumConfig)
            if freshData.Gum[max_gum_item] then
                max_Gum_Reached = true
            else
                max_Gum_Reached = false
            end
        else
            max_Gum_Reached = false
        end
        
        max_Upgrades_Reached = max_Flavor_Reached and max_Gum_Reached
        
        local function checkMasteryCompleted(masteryTargets)
            if not masteryTargets or #masteryTargets == 0 then
                return true
            end
            return false
        end
        
        FindAvailableAndMastery()
        
        PetsMasteryCompleted = checkMasteryCompleted(Mastery_Pets_Targets)
        BuffsMasteryCompleted = checkMasteryCompleted(Mastery_Buffs_Targets)
        ShopsMasteryCompleted = checkMasteryCompleted(Mastery_Shops_Targets)
        
        AllMasteryCompleted = PetsMasteryCompleted and BuffsMasteryCompleted and ShopsMasteryCompleted
        
        return true
    end
    
    return false
end

-- 🌀━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Main Loop ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌀

while true do
    local success, errorMsg = pcall(function()

        if not hasHandledIntro then
            hasHandledIntro = handleIntro()
            if hasHandledIntro then
                task.wait(5)
                InitializePlayerData()
                task.wait(10)
            end
        end

        if not AreaUnlock_Toggle and not areasUnlocked then
            areasUnlocked = UnlockAreas()
        end

        if not isFlyModeActive then
            toggleFlyMode()
        end

        if not isAutoMastery then
            FindAvailableAndMastery()
        end

        if PetsMasteryCompleted and BuffsMasteryCompleted then
            if not isAutoHatching then
                toggleAutoHatch()
            elseif isAutoHatching and not isAutoUsingPotions then
                toggleAutoUsePotion()
            end
        else
            if not Auto_Bubble_And_Sell_Active and not isAutoHatching then
                Auto_Bubble_And_Sell()
            end
        end

        if not isAutoDeletingPets then
            toggleAutoPetDeletion()
        end

        if not CheckRewards_Toggle and not hasClaimedDailyReward then
            hasClaimedDailyReward = checkDailyRewards()
        end

        if not AutoClaimPlaytime_Toggle and not PlaytimeRewardsClaimed then
            toggleAutoClaimPlaytime()
        end

        if not SetSettings_Toggle and not settingsApplied then
            SetOptimalSettings()
        end

        if not AutoClaimPrizes_Toggle then
            toggleAutoClaimPrizes()
        end
        
        if not AutoBuy_Toggle and not max_Upgrades_Reached then
            AutoBuy_Toggle, max_Flavor_Reached, max_Gum_Reached, max_Upgrades_Reached = AutoBuyItems()
        end
        
        if not AutoHideOverlay_Toggle then
            toggleAutoHideOverlay()
        end
        
        if not AutoMysteryBoxes_Toggle then
            toggleAutoMysteryBoxes()
        end

        if not AutoWheelSpin_Toggle then
            toggleAutoWheelSpin()
        end

        if not isAutoCraftingPotions then
            toggleAutoCraftPotions()
        end

        if not RerollEnchants_Toggle and (PetsMasteryCompleted and BuffsMasteryCompleted) then
            RerollEnchants()
        end

        if not isPressingB then
            togglePeriodicB()
        end    

        if not isAutoBuyingShopItems then
            toggleAutoBuyShopItems()
        end

        if not SecretPetCheck_Toggle then
            checkForSecretPets()
        end

        if not isEggCounterEnabled then
            toggleEggCounter()
        end

        task.wait(0.2)
    end)
    
    if not success then
        print("ERROR IN MAIN LOOP: " .. tostring(errorMsg))
        task.wait(2)
    end
    
    task.wait(0.1)
end
